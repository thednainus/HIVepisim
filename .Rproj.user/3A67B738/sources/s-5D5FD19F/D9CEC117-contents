#' @title Transmission Module
#'
#' @description Stochastically simulates disease transmission given the current
#'              state of the discordand edgelist. This function should be used
#'              when there is migration.
#'
#' @inheritParams EpiModelHIV::aging_msm
#'
#' @details
#' This is the final substantive function that occurs within the time loop at
#' each time step. This function takes the discordant edgelist and calculates a
#' transmission probability for each row between dyads on the
#' network. After transmission events, individual-level attributes for the infected
#' persons are updated and summary statistics for incidence calculated.
#'
#' @return
#' For each new infection, the disease status, infection time, and related
#' HIV attributes are updated for the infected node. Summary statistics for
#' disease incidence overall are calculated and stored on \code{dat$epi}.
#'
#'
#' @export
#'
hivtrans_msm_sdiego_mig <- function(dat, at) {

  # Variables -----------------------------------------------------------

  # Attributes
  active <- dat$attr$active
  stage <- dat$attr$stage
  status <- dat$attr$status
  diag.status <- dat$attr$diag.status
  tx.status <- dat$attr$tx.status
  risk.group <- dat$att$risk.group
  cuml.time.on.tx <- dat$attr$cuml.time.on.tx
  cuml.time.off.tx <- dat$attr$cuml.time.off.tx
  infTime <- dat$attr$infTime
  uid <- dat$attr$uid
  migrant <- dat$attr$migrant

  # Parameters
  # baseline for transmission rate
  trans.r <- dat$param$trans.r

  # transmission risk ratio by stage of HIV infection
  ws0 <- dat$param$ws0
  ws1 <- dat$param$ws1
  ws2 <- dat$param$ws2
  ws3 <- dat$param$ws3
  ws4 <- dat$param$ws4

  # Transmission risk ratio
  # by care status (undiagnosed; diagnosed and untreated; and diagnosed an treated)
  wc1 <- dat$param$wc1
  wc2 <- dat$param$wc2
  wc3 <- dat$param$wc3

  # Transmission risk ratio
  # by risk group
  wr1 <- dat$param$wr1
  wr2 <- dat$param$wr2


  ## Find infected nodes ##
  infstat <- "1" # refer to status = 1
  idsInf <- which(active == 1 & status %in% infstat)
  nActive <- sum(active == 1)
  nElig <- length(idsInf)

  ## Initialize default incidence at 0 ##
  nInf <- NULL

  if (nElig > 0 && nElig < nActive) {

    ## Look up discordant edgelist ##
    del <- discord_edgelist_msm_mig(dat, at)


    ## If any discordant pairs, proceed ##
    if (!(is.null(del))) {

      inf_indexes <- match(del$inf, uid)
      #sus_indexes <- match(del$sus, uid)

      del$infDur <- at - infTime[inf_indexes]
      del$infDur[del$infDur == 0] <- 1
      del$status <- status[inf_indexes]
      del$risk.group <- risk.group[inf_indexes]
      del$stage <- stage[inf_indexes]
      del$tx.status <- tx.status[inf_indexes]
      del$cuml.time.on.tx <- cuml.time.on.tx[inf_indexes]
      del$cuml.time.off.tx <- cuml.time.off.tx[inf_indexes]
      del$diag.status <- diag.status[inf_indexes]
      del$migrant <- migrant[inf_indexes]

      #del$susOrigin <- origin[sus_indexes]
      #del$susMigrant <- migrant[sus_indexes]

      #print(del[del$susOrigin != del$origin,])
      #del <- del[del$origin == del$susOrigin,]

      teste <- del[del$infOrigin != del$susOrigin,]
      if(length(teste$susOrigin) > 0){
        print("DIFERENTES")
      }


      # Set parameters on discordant edgelist data frame
      del$trans.r <- rep(trans.r, length(del$inf))

      # stages of HIV infection (following Cori et al. 2015)
      del$trans.r[del$stage == 0] <- del$trans.r[del$stage == 0] * ws0
      del$trans.r[del$stage == 1] <- del$trans.r[del$stage == 1] * ws1
      del$trans.r[del$stage == 2] <- del$trans.r[del$stage == 2] * ws2
      del$trans.r[del$stage == 3] <- del$trans.r[del$stage == 3] * ws3
      del$trans.r[del$stage == 4] <- del$trans.r[del$stage == 4] * ws4

      # Treatment status and tested status
      #is not tested
      del$trans.r[del$diag.status == 0] <- del$trans.r[del$diag.status == 0] * wc1
      # is off treatment
      del$trans.r[del$tx.status == 0 & del$cuml.time.off.tx > 0] <-
        del$trans.r[del$tx.status == 0 & del$cuml.time.off.tx > 0] * wc2
      #is tested but not on treatment
      del$trans.r[del$diag.status == 1 & del$tx.status == 0 & del$cuml.time.on.tx == 0] <-
        del$trans.r[del$diag.status == 1 & del$tx.status == 0 & del$cuml.time.on.tx == 0] * wc2
      #is on treatment
      del$trans.r[del$tx.status == 1 & del$cuml.time.on.tx > 0] <-
        del$trans.r[del$tx.status == 1 & del$cuml.time.on.tx > 0] * wc3

      # risk groups
      del$trans.r[del$risk.group == 1] <- del$trans.r[del$risk.group == 1] * wr1
      del$trans.r[del$risk.group == 2] <- del$trans.r[del$risk.group == 2] * wr2


      # Transmission from infected person --------------------------------------

      transmit <- rbinom(length(del$inf), 1, del$trans.r*365)
      idsTrans <- which(transmit == 1)

      # Subset discord edgelist to transmissions
      del <- keep.attr(del, idsTrans)


      # Look up new ids if any transmissions occurred
      ## Update Nodal Attr
      idsNewInf <- unique(del$sus)
      index_idsNewInf <- match(idsNewInf, uid)
      idsTrans <- unique(del$inf)
      index_idsTrans <- match(idsTrans, uid)
      nInf <- length(idsNewInf)


      if (nInf > 0) {

        # Attributes of newly infected
        dat$attr$status[index_idsNewInf] <- 1
        dat$attr$infTime[index_idsNewInf] <- at
        dat$attr$stage[index_idsNewInf] <- 0
        dat$attr$stage.time[index_idsNewInf] <- 0
        dat$attr$diag.status[index_idsNewInf] <- 0
        dat$attr$tx.status[index_idsNewInf] <- 0
        dat$attr$cuml.time.on.tx[index_idsNewInf] <- 0
        dat$attr$cuml.time.off.tx[index_idsNewInf] <- 0

        # Attributes of transmitter
        #transmitter <- as.numeric(del$inf)
        transmitter <- as.numeric(index_idsTrans)
        tab.trans <- table(transmitter)
        uni.trans <- as.numeric(names(tab.trans))
        dat$attr$count.trans[uni.trans] <- dat$attr$count.trans[uni.trans] +
          as.numeric(tab.trans)

        ## Transmission data frame
        if (dat$control$save.transmat == TRUE) {
          if (nInf > 0) {
            if (at == 2) {
              dat$stats$transmat <- as.data.frame(del)
            } else {
              dat$stats$transmat <- rbind(dat$stats$transmat, as.data.frame(del))
            }
          }
        }


        if (length(idsNewInf) > 0) {
          # Summary Output
          dat$epi$incid[at] <- length(idsNewInf)
          dat$epi$incid.undx[at] <- sum(dat$attr$diag.status[transmitter] == 0)
          dat$epi$incid.dx[at] <- sum(dat$attr$diag.status[transmitter] == 1 &
                                        dat$attr$cuml.time.on.tx[transmitter] == 0)
          #dat$epi$incid.linked[at] <- sum(dat$attr$diag.status[transmitter] == 1 &
          #                                 dat$attr$cuml.time.on.tx[transmitter] > 0)
        } else {
          dat$epi$incid[at] <- length(nInf)
          dat$epi$incid.undx[at] <- 0
          dat$epi$incid.dx[at] <- 0
          #dat$epi$incid.linked[at] <- 0
        }
      }
    }
  }

  return(dat)
}

#' @export
discord_edgelist_msm_mig <- function(dat, at, network = 1) {

  status <- dat$attr$status
  active <- dat$attr$active
  origin <- dat$attr$origin
  uid <- dat$attr$uid
  infstat <- 1
  tergmLite <- get_control(dat, "tergmLite")

  if (tergmLite == TRUE) {
    el <- dat$el[[network]]
  }
  else {
    el <- get.dyads.active(dat$nw[[network]], at = at)
  }

  del <- NULL

  if (nrow(el) > 0) {
    el <- el[sample(1:nrow(el)), , drop = FALSE]
    #stat <- matrix(status[el], ncol = 2)
    indexes <- match(c(el), uid)
    stat <- matrix(status[indexes], ncol = 2)
    isInf <- matrix(stat %in% infstat, ncol = 2)
    isSus <- matrix(stat %in% 0, ncol = 2)

    SIpairs <- el[isSus[, 1] * isInf[, 2] == 1, , drop = FALSE]
    ISpairs <- el[isSus[, 2] * isInf[, 1] == 1, , drop = FALSE]
    pairs <- rbind(SIpairs, ISpairs[, 2:1])

    if (nrow(pairs) > 0) {
      sus <- pairs[, 1]
      inf <- pairs[, 2]
      sus_index <- match(sus, uid)
      inf_index <- match(inf, uid)
      infOrigin <- origin[inf_index]
      susOrigin <- origin[sus_index]
      del <- data.frame(at, sus, inf, infOrigin, susOrigin)
      #keep <- rowSums(matrix(c(active[del$sus], active[del$inf]),
      #                       ncol = 2)) == 2
      keep <- rowSums(matrix(c(active[sus_index], active[inf_index]),
                             ncol = 2)) == 2
      del <- del[keep, ]
      if (nrow(del) < 1) {
        del <- NULL
      }
    }
  }
  return(del)
}


#' @export
keep.attr <- function(attrList, keep) {
  lapply(attrList, function(x) x[keep])
}
